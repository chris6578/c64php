<?php

namespace Mos6510;

class Disassembler {

    /** @var Cpu */
    protected $cpu;

    /** @var Memory */
    protected $memory;
    
    protected $opcode_name = array(
    /*0x01*/    "BRK","ORA","KIL","SLO","NOP","ORA","ASL","SLO","PHP","ORA","ASL","ANC","NOP","ORA","ASL","SLO",
    /*0x10*/    "BPL","ORA","KIL","SLO","NOP","ORA","ASL","SLO","CLC","ORA","NOP","SLO","NOP","ORA","ASL","SLO",
    /*0x20*/    "JSR","AND","KIL","RLA","BIT","AND","ROL","RLA","PLP","AND","ROL","ANC","BIT","AND","ROL","RLA",
    /*0x30*/    "BMI","AND","KIL","RLA","NOP","AND","ROL","RLA","SEC","AND","NOP","RLA","NOP","AND","ROL","RLA",
    /*0x40*/    "RTI","EOR","KIL","SRE","NOP","EOR","LSR","SRE","PHA","EOR","LSR","ALR","JMP","EOR","LSR","SRE",
    /*0x50*/    "BVC","EOR","KIL","SRE","NOP","EOR","LSR","SRE","CLI","EOR","NOP","SRE","NOP","EOR","LSR","SRE",
    /*0x60*/    "RTS","ADC","KIL","RRA","NOP","ADC","ROR","RRA","PLA","ADC","ROR","ARR","JMP","ADC","ROR","RRA",
    /*0x70*/    "BVS","ADC","KIL","RRA","NOP","ADC","ROR","RRA","SEI","ADC","NOP","RRA","NOP","ADC","ROR","RRA",
    /*0x80*/    "NOP","STA","NOP","SAX","STY","STA","STX","SAX","DEY","NOP","TXA","XAA","STY","STA","STX","SAX",
    /*0x90*/    "BCC","STA","KIL","AHX","STY","STA","STX","SAX","TYA","STA","TXS","TAS","SHY","STA","SHX","AHX",
    /*0xA0*/    "LDY","LDA","LDX","LAX","LDY","LDA","LDX","LAX","TAY","LDA","TAX","LAX","LDY","LDA","LDX","LAX",
    /*0xB0*/    "BCS","LDA","KIL","LAX","LDY","LDA","LDX","LAX","CLV","LDA","TSX","LAS","LDY","LDA","LDX","LAX",
    /*0xC0*/    "CPY","CMP","NOP","DCP","CPY","CMP","DEC","DCP","INY","CMP","DEX","AXS","CPY","CMP","DEC","DCP",
    /*0xD0*/    "BNE","CMP","KIL","DCP","NOP","CMP","DEC","DCP","CLD","CMP","NOP","DCP","NOP","CMP","DEC","DCP",
    /*0xE0*/    "CPX","SBC","NOP","ISC","CPX","SBC","INC","ISC","INX","SBC","NOP","SBC","CPX","SBC","INC","ISC",
    /*0xF0*/    "BEQ","SBC","KIL","ISC","NOP","SBC","INC","ISC","SED","SBC","NOP","ISC","NOP","SBC","INC","ISX",
    );

    protected $opcode_size = array(
        /*0x00*/    1,2,1,1,1,2,2,1,1,2,1,1,1,3,3,1,
        /*0x10*/    2,2,1,1,1,2,2,1,1,3,1,1,1,3,3,1,
        /*0x20*/    3,2,1,1,2,2,2,1,1,2,1,1,3,3,3,1,
        /*0x30*/    2,2,1,1,1,2,2,1,1,3,1,1,1,3,3,1,
        /*0x40*/    1,2,1,1,1,2,2,1,1,2,1,1,3,3,3,1,
        /*0x50*/    2,2,1,1,1,2,2,1,1,3,1,1,1,3,3,1,
        /*0x60*/    1,2,1,1,1,2,2,1,1,2,1,1,3,3,3,1,
        /*0x70*/    2,2,1,1,1,2,2,1,1,3,1,1,1,3,3,1,
        /*0x80*/    1,2,1,1,2,2,2,1,1,1,1,1,3,3,3,1,
        /*0x90*/    2,2,1,1,2,2,2,1,1,3,1,1,1,3,1,1,
        /*0xA0*/    2,2,2,1,2,2,2,1,1,2,1,1,3,3,3,1,
        /*0xB0*/    2,2,1,1,2,2,2,1,1,3,1,1,3,3,3,1,
        /*0xC0*/    2,2,1,1,2,2,2,1,1,2,1,1,3,3,3,1,
        /*0xD0*/    2,2,1,1,1,2,2,1,1,3,1,1,1,3,3,1,
        /*0xE0*/    2,2,1,1,2,2,2,1,1,2,1,1,3,3,3,1,
        /*0xF0*/    2,2,1,1,1,2,2,1,1,3,1,1,1,3,3,1,
    );

    protected $opcode_mode = array(
        /*0x00*/   11, 1, 0, 0, 0, 2, 2, 0,11, 0,11, 0, 0, 3, 3, 0,
        /*0x10*/    9, 4, 0, 0, 0, 5, 5, 0,11, 6, 0, 0, 0, 7, 7, 0,
        /*0x20*/    3, 1, 0, 0, 2, 2, 2, 0,11, 0,11, 0, 3, 3, 3, 0,
        /*0x30*/    9, 4, 0, 0, 0, 5, 5, 0,11, 6, 0, 0, 0, 7, 7, 0,
        /*0x40*/   11, 1, 0, 0, 0, 2, 2, 0,11, 0,11, 0, 3, 3, 3, 0,
        /*0x50*/    9, 4, 0, 0, 0, 5, 5, 0,11, 6, 0, 0, 0, 7, 7, 0,
        /*0x60*/   11, 1, 0, 0, 0, 2, 2, 0,11, 0,11, 0,10, 3, 3, 0,
        /*0x70*/    9, 4, 0, 0, 0, 5, 5, 0,11, 6, 0, 0, 0, 7, 7, 0,
        /*0x80*/    0, 1, 0, 0, 2, 2, 2, 0,11, 0,11, 0, 3, 3, 3, 0,
        /*0x90*/    9, 4, 0, 0, 5, 5, 8, 0,11, 6,11, 0, 0, 7, 0, 0,
        /*0xA0*/    0, 1, 0, 0, 2, 2, 2, 0,11, 0,11, 0, 3, 3, 3, 0,
        /*0xB0*/    9, 4, 0, 0, 5, 5, 8, 0,11, 6,11, 0, 7, 7, 6, 0,
        /*0xC0*/    0, 1, 1, 1, 2, 2, 2, 0,11, 0,11, 0, 3, 3, 3, 0,
        /*0xD0*/    9, 4, 0, 0, 0, 5, 5, 0,11, 6, 0, 0, 0, 7, 7, 0,
        /*0xE0*/    0, 1, 0, 0, 2, 2, 2, 0,11, 0, 0, 0, 3, 3, 3, 0,
        /*0xF0*/    9, 4, 0, 0, 0, 5, 5, 0,11, 6,11, 0, 0, 7, 7, 0,
        /*          0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
    );

    const MODE_IMP = 11;
    const MODE_IMM = 0;
    const MODE_INX = 1;
    const MODE_ZP  = 2;
    const MODE_ABS = 3;
    const MODE_INY = 4;
    const MODE_ZPX = 5;
    const MODE_ABY = 6;
    const MODE_ABX = 7;
    const MODE_ZPY = 8;
    const MODE_REL = 9;
    const MODE_IND = 10;

    /**
     * Disassembler constructor.
     * @param C64 $c64
     */
    public function __construct(C64 $c64)
    {
        $this->cpu = $c64->getCpu();
        $this->memory = $c64->getMemory();
    }


    /**
     * Output a disassembly structure as generated by Disassembler::disassemble();
     *
     * @param $dis_struct
     * @param int $pc           Highlight certain line
     * @return string
     */
    public function output($dis_struct, $pc = -1) {
        $output = "";

        foreach ($dis_struct as $entry) {
            $s = ($entry['offset'] == $pc) ? ">\033[44m" : " ";
            $output .= sprintf("%s \033[31m%04X   \033[32m%-10s   \033[33m%-15s  \e[35m%-20s                \033[0m", $s, $entry['offset'], $entry['operands_str'], $entry['mnemonic'], $entry['ram']);
            $output .= "\033[0m";
            $output .= "\n";
        }

        return $output;
    }

    /**
     * Creates a disassemly from given $location for $lines instructions
     *
     * @param $location
     * @param $lines
     * @return array
     */
    public function disassemble($location, $lines) {
        $struct = array();

        $offset = 0;
        for ($line=0; $line<$lines; $line++) {
            $entry = array();

            $startOffset = $location + $offset;
            if ($startOffset > 0xFFFF) {
                continue;
            }
            $entry['offset'] = $startOffset;            // Memory offset (0000 - FFFF)

            $codes = "";
            $dis = "";

            // Get opcode
            $opcode = $this->cpu->memory->read8($location + $offset++);
            $entry['opcode'] = $opcode;             // Opcode byte (0xA9 etc)

            $codes .= sprintf("%02X ", $opcode);

            $name = $this->opcode_name[$opcode];
            $dis .= $name." ";

            $entry['opcode_name'] = $name;      // Opcode name (ie: LDA, JMP etc)


            $operands = array(0, 0);
            $len = $this->opcode_size[$opcode];
            for ($i=0; $i < $len-1; $i++) {
                $operands[$i] = $operand = $this->cpu->memory->read8($location + $offset++);
                $codes .= sprintf("%02X ", $operand);
            }


            $entry['operands_len'] = $len;          // Number of operands for this instruction
            $entry['operands'] = $operands;         // Actual operands array (ie: array(0xA9, 0x05)
            $entry['operands_str'] = $codes;        // Textual hex representation of whole instruction (ie: "A9 05")

            $entry['ram'] = "";     // RAM description (ie: "[0400] -> D8", meaning instruction fetches data (0xD8) which is located at memory location 0x0400)

            $mode = $this->opcode_mode[$opcode];
            switch ($mode) {
                case self::MODE_IMP:
                    $dis .= "";
                    break;
                case self::MODE_IMM:
                    if ($len == 2) {
                        $dis .= sprintf("#$%02X", $operands[0]);
                    } else {
                        $dis .= sprintf("#$%04X", $operands[1] * 256 + $operands[0]);
                    }
                    break;
                case self::MODE_ZP:
                    $dis .= sprintf("$%02X", $operands[0]);
                    $loc = Memory::ZERO_PAGE_ADDR + $operands[0];
                    $entry['ram'] = sprintf("[%04X] -> %02X", $loc, $this->memory->read8($loc));
                    break;
                case self::MODE_ZPX:
                    $dis .= sprintf("$%02X,X", $operands[0]);
                    $loc = Memory::ZERO_PAGE_ADDR + $operands[0] + $this->cpu->readX();
                    $entry['ram'] = sprintf("[%04X] -> %02X", $loc, $this->memory->read8($loc));
                    break;
                case self::MODE_ZPY:
                    $dis .= sprintf("$%02X,Y", $operands[0]);
                    $loc = Memory::ZERO_PAGE_ADDR + $operands[0] + $this->cpu->readY();
                    $entry['ram'] = sprintf("[%04X] -> %02X", $loc, $this->memory->read8($loc));
                    break;
                case self::MODE_INX:
                    if ($len == 2) {
                        $dis .= sprintf("($%02X),X", $operands[0]);
                        $loc1 = $operands[0];
                    } else {
                        $dis .= sprintf("($%04X),X", $operands[1] * 256 + $operands[0]);
                        $loc1 = $operands[1] * 256 + $operands[0];
                    }

                    $loc2 = $this->memory->read16($loc1 + $this->cpu->readX());
                    $entry['ram'] = sprintf("[%04X + %02X] -> [%04X] -> %02X", $loc1, $this->cpu->readX(), $loc2, $this->memory->read8($loc2));
                    break;
                case self::MODE_INY:
                    if ($len == 2) {
                        $dis .= sprintf("($%02X),Y", $operands[0]);
                        $loc1 = $operands[0];
                    } else {
                        $dis .= sprintf("($%04X),Y", $operands[1] * 256 + $operands[0]);
                        $loc1 = $operands[1] * 256 + $operands[0];
                    }
                    $loc2 = $this->memory->read16($loc1);
                    $entry['ram'] = sprintf("[%04X] -> [%04X + %02X] -> %02X", $loc1, $loc2, $this->cpu->readY(), $this->memory->read8($loc2 + $this->cpu->readY()));
                    break;
                case self::MODE_ABS:
                    $dis .= sprintf("$%04X", $operands[1] * 256 + $operands[0]);
                    $loc = $operands[1] * 256 + $operands[0];
                    $entry['ram'] = sprintf("[%04X] -> %02X", $loc, $this->memory->read8($loc));
                    break;
                case self::MODE_ABX:
                    $dis .= sprintf("$%04X,X", $operands[1] * 256 + $operands[0]);
                    $loc = $operands[1] * 256 + $operands[0] + $this->cpu->readX();
                    $entry['ram'] = sprintf("[%04X] -> %02X", $loc, $this->memory->read8($loc));
                    break;
                case self::MODE_ABY:
                    $dis .= sprintf("$%04X,Y", $operands[1] * 256 + $operands[0]);
                    $loc = ($operands[1] * 256) + $operands[0] + $this->cpu->readY();
                    $entry['ram'] = sprintf("[%04X] -> %02X", $loc, $this->memory->read8($loc));
                    break;
                case self::MODE_IND:
                    $dis .= sprintf("($%04X)", $operands[1] * 256 + $operands[0]);

                    $loc1 = $operands[1] * 256 + $operands[0];
                    $loc2 = $this->memory->read16($loc1);
                    $entry['ram'] = sprintf("[%04X] -> [%04X] -> %02X", $loc1, $loc2, $this->memory->read8($loc2));
                    break;
                case self::MODE_REL:
                    $target = $location + $offset + $operands[0];

                    if (($operands[0] & 0x80) == 0x80) {
                        $target = $location + $offset + (0 - (255 - $operands[0]) - 1);
                    }
                    $dis .= sprintf("$%04X", $target);
                    break;
            }

            $entry['mnemonic'] = $dis;      // Complete mnemonic instruction (ie: "BNE $33A7")



            $struct[] = $entry;
        }

        return $struct;
    }


    /**
     * Creates debug snapshot
     *
     * @return string
     */
    public function getDebugSnapshot()
    {
        $f = "";
        $f .= $this->cpu->flagIsSet(Cpu::P_FLAG_NEGATIVE) ? "N" : "n";
        $f .= $this->cpu->flagIsSet(Cpu::P_FLAG_OVERFLOW) ? "O" : "o";
        $f .= "1";
        $f .= $this->cpu->flagIsSet(Cpu::P_FLAG_BREAK) ? "B" : "b";
        $f .= $this->cpu->flagIsSet(Cpu::P_FLAG_DECIMAL) ? "D" : "d";
        $f .= $this->cpu->flagIsSet(Cpu::P_FLAG_IRQ_DISABLE) ? "I" : "i";
        $f .= $this->cpu->flagIsSet(Cpu::P_FLAG_ZERO) ? "Z" : "z";
        $f .= $this->cpu->flagIsSet(Cpu::P_FLAG_CARRY) ? "C" : "c";


        $s = "";

        $s .= sprintf("----- DEBUG STACK ON CYCLE %010d ----- \n", $this->cpu->getTickCount());

        $s .= sprintf("    A: %02X        PC: %04X\n", $this->cpu->readA(), $this->cpu->readPc());
        $s .= sprintf("    X: %02X        S : %02X\n", $this->cpu->readX(), $this->cpu->readS());
        $s .= sprintf("    Y: %02X        P : %s\n", $this->cpu->readY(), $f);
        $s .= "\n";
        $s .= "Stack: ";

        $o = $this->cpu->readS() + 20;
        if ($o > 0xFF) {
            $o = 0xFF;
        }
        $i=0;
        while ($o > $this->cpu->readS()) {
            $s .= sprintf("%02X ", $this->memory->read8(Memory::STACK_PAGE_ADDR + $o));
            $o--;
            $i++;
        }
        while ($i < 20) {
            $s .= sprintf("   ");
            $i++;
        }

        $s .= "\n";

        $s .= "------------------------------------------------- \n";
        $struct = $this->disassemble($this->cpu->readPc(), 15);
        $s .= $this->output($struct, $this->cpu->readPc());
        $s .= "------------------------------------------------- \n";

        return $s;
    }

    function getMemoryDump($offset, $lines, $display_ascii = true, $direct_from_ram = false) {
        $s = "";

        for ($y=0; $y!=$lines; $y++) {
            $bytes = array();
            for ($i=0; $i!=16; $i++) {
                if ($direct_from_ram) {
                    $bytes[] = $this->memory->read8ram($offset + $i);
                } else {
                    $bytes[] = $this->memory->read8($offset + $i);
                }
            }


            $ascii = "";
            if ($display_ascii) {
                $ascii = "| ";

                for ($i=0; $i!=16; $i++) {
                   $c = $bytes[$i];
                    if ($c >= 32 && $c <= 127) {
                        $ascii .= chr($c);
                    } else {
                        $ascii .= ".";
                    }
                }
            }

            $s .= sprintf("%04X  | %02X %02X %02X %02X | %02X %02X %02X %02X | %02X %02X %02X %02X | %02X %02X %02X %02X %s\n",
                    $offset,
                    $bytes[0], $bytes[1], $bytes[2], $bytes[3],
                    $bytes[4], $bytes[5], $bytes[6], $bytes[7],
                    $bytes[8], $bytes[9], $bytes[10], $bytes[11],
                    $bytes[12], $bytes[13], $bytes[14], $bytes[15],
                    $ascii
            );
            $offset += 16;
        }

        return $s;
    }

}
